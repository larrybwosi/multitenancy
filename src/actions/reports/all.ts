// Presumed Prisma Client import
// import { PrismaClient, Department, Sale, Expense, InventoryLocation, Member, Organization, UserRole, MemberRole, LocationType, ExpenseStatus, PaymentMethod, PaymentStatus, StockAdjustmentReason, MovementType } from '@/prisma/client'; 
import prisma from '@/lib/db';

// --- Helper Function (Conceptual) ---
// This would be replaced by actual Prisma Client calls within each function.
// For brevity, I won't repeat a generic helper like in Python,
// but rather show Prisma-like calls directly in the report functions.

// --- Type Definitions (Basic examples, Prisma generates more precise types) ---
// You would typically rely on types generated by Prisma.
// These are illustrative.

interface ReportError {
  error: string;
}

interface DepartmentReportData {
  department_info: any; // Replace with specific Prisma type like DepartmentGetPayload
  expenses: any[]; // Replace with specific Prisma type like ExpenseGetPayload[]
  members: any[]; // Replace with specific Prisma type like DepartmentMemberGetPayload[]
}

interface SalesReportData {
  summary: {
    total_sales_value: number;
    number_of_sales: number;
  };
  sales: any[]; // Replace with specific Prisma type like SaleGetPayload[]
}

interface ExpensesReportData {
  summary: {
    total_expenses_value: number;
    number_of_expenses: number;
  };
  expenses: any[]; // Replace with specific Prisma type like ExpenseGetPayload[]
}

interface WarehouseReportData {
  warehouse_info: any; // InventoryLocationGetPayload
  variant_stock_levels: any[]; // ProductVariantStockGetPayload[]
  stock_batches: any[]; // StockBatchGetPayload[]
  stock_movements: any[]; // StockMovementGetPayload[]
}

interface MembersReportData {
  members: any[]; // MemberGetPayload[]
  message?: string;
}

interface OrganizationReportData {
  organization_info: any; // OrganizationGetPayload
  member_count: number;
  customer_count: number;
  product_count: number;
  sales_summary: any;
  expenses_summary: any;
  kpis: {
    total_revenue?: number;
    total_expenses?: number;
    new_customers_in_period?: number;
  };
}

interface ReportResponse {
  report_type: string;
  data:
    | DepartmentReportData
    | SalesReportData
    | ExpensesReportData
    | WarehouseReportData
    | MembersReportData
    | OrganizationReportData
    | { message?: string };
  generated_at: string;
}

// --- Report Generation Functions ---

async function generateDepartmentReport(
  prisma: any, // Pass your Prisma client instance
  departmentId: string,
  startDate: Date,
  endDate: Date
): Promise<ReportResponse | ReportError> {
  try {
    console.log(
      `Generating Department Report for ID: ${departmentId} from ${startDate.toISOString()} to ${endDate.toISOString()}`
    );

    const departmentDetails = await prisma.department.findUnique({
      where: { id: departmentId },
      include: {
        head: { include: { user: true } }, // [cite: 31, 32]
        departmentMembers: { include: { member: { include: { user: true } } } }, // [cite: 12]
        activeBudget: true, // [cite: 33]
        budgets: {
          // [cite: 33]
          where: {
            // Filter budgets if needed by date, though expenses are date-filtered below
          },
        },
      },
    });

    if (!departmentDetails) {
      return { error: `Department with ID ${departmentId} not found.` };
    }

    const budgetIds = departmentDetails.budgets?.map((b: any) => b.id).filter(Boolean) || [];
    let departmentExpenses: any[] = [];

    if (budgetIds.length > 0) {
      departmentExpenses = await prisma.expense.findMany({
        where: {
          budgetId: { in: budgetIds }, // [cite: 213]
          expenseDate: { gte: startDate, lte: endDate }, // [cite: 201]
        },
        include: {
          category: true, // [cite: 201]
          member: { include: { user: true } }, // [cite: 207]
        },
      });
    }

    const reportData: DepartmentReportData = {
      department_info: departmentDetails,
      expenses: departmentExpenses,
      members: departmentDetails.departmentMembers || [],
    };

    return {
      report_type: 'Department',
      data: reportData,
      generated_at: new Date().toISOString(),
    };
  } catch (e: any) {
    return { error: `Failed to generate department report: ${e.message}` };
  }
}

async function generateSalesReport(
  prisma: any,
  organizationId: string,
  startDate: Date,
  endDate: Date,
  memberId?: string,
  locationId?: string
): Promise<ReportResponse | ReportError> {
  try {
    console.log(
      `Generating Sales Report for Organization ID: ${organizationId} from ${startDate.toISOString()} to ${endDate.toISOString()}`
    );
    const filters: any = {
      organizationId: organizationId,
      saleDate: { gte: startDate, lte: endDate }, // [cite: 67]
    };
    if (memberId) filters.memberId = memberId; // [cite: 66]
    if (locationId) filters.locationId = locationId; // [cite: 68]

    const salesData = await prisma.sale.findMany({
      where: filters,
      include: {
        customer: true, // [cite: 66]
        member: { include: { user: true } }, // [cite: 6]
        items: { include: { variant: { include: { product: true } } } }, // [cite: 73]
        location: true, // [cite: 68]
      },
    });

    const summary = {
      total_sales_value: salesData.reduce((sum, s) => sum + (s.finalAmount?.toNumber() || 0), 0), // [cite: 67]
      number_of_sales: salesData.length,
    };

    const reportData: SalesReportData = { summary, sales: salesData };

    return {
      report_type: 'Sales',
      data: reportData,
      generated_at: new Date().toISOString(),
    };
  } catch (e: any) {
    return { error: `Failed to generate sales report: ${e.message}` };
  }
}

async function generateExpensesReport(
  prisma: any,
  organizationId: string,
  startDate: Date,
  endDate: Date,
  memberId?: string,
  categoryId?: string
): Promise<ReportResponse | ReportError> {
  try {
    console.log(
      `Generating Expenses Report for Organization ID: ${organizationId} from ${startDate.toISOString()} to ${endDate.toISOString()}`
    );
    const filters: any = {
      organizationId: organizationId, // [cite: 210]
      expenseDate: { gte: startDate, lte: endDate }, // [cite: 201]
    };
    if (memberId) filters.memberId = memberId; // [cite: 207]
    if (categoryId) filters.categoryId = categoryId; // [cite: 201]

    const expensesData = await prisma.expense.findMany({
      where: filters,
      include: {
        category: true, // [cite: 201]
        member: { include: { user: true } }, // [cite: 207]
        approver: { include: { user: true } }, // [cite: 207, 208]
        location: true, // [cite: 205, 206]
        attachments: true, // [cite: 168]
      },
    });

    const summary = {
      total_expenses_value: expensesData.reduce((sum, e) => sum + (e.amount?.toNumber() || 0), 0), // [cite: 200]
      number_of_expenses: expensesData.length,
    };

    const reportData: ExpensesReportData = { summary, expenses: expensesData };

    return {
      report_type: 'Expenses',
      data: reportData,
      generated_at: new Date().toISOString(),
    };
  } catch (e: any) {
    return { error: `Failed to generate expenses report: ${e.message}` };
  }
}

async function generateWarehouseReport(
  prisma: any,
  warehouseId: string,
  startDate: Date,
  endDate: Date
): Promise<ReportResponse | ReportError> {
  try {
    console.log(
      `Generating Warehouse Report for ID: ${warehouseId} from ${startDate.toISOString()} to ${endDate.toISOString()}`
    );

    const warehouseDetails = await prisma.inventoryLocation.findFirst({
      where: { id: warehouseId, locationType: 'WAREHOUSE' }, // [cite: 96]
      include: {
        parentLocation: true, // [cite: 101, 102]
        childLocations: true, // [cite: 102]
        manager: { include: { user: true } }, // [cite: 104, 105]
      },
    });

    if (!warehouseDetails) {
      return { error: `Warehouse with ID ${warehouseId} not found or is not a warehouse.` };
    }

    const variantStocks = await prisma.productVariantStock.findMany({
      where: {
        locationId: warehouseId, // [cite: 142]
        // Filtering by product/variant update date is complex here,
        // Consider if this level of date filtering for stocks is essential or if current levels are enough.
        // lastUpdated: { gte: startDate, lte: endDate } // This field is on ProductVariantStock [cite: 143]
      },
      include: { variant: { include: { product: true } } }, // [cite: 142]
    });

    const stockBatches = await prisma.stockBatch.findMany({
      where: {
        locationId: warehouseId, // [cite: 132]
        OR: [
          { receivedDate: { gte: startDate, lte: endDate } }, // [cite: 137]
          { expiryDate: { gte: startDate, lte: endDate } }, // [cite: 137]
        ],
      },
      include: { variant: { include: { product: true } }, supplier: true }, // [cite: 130, 139]
    });

    const stockMovements = await prisma.stockMovement.findMany({
      where: {
        OR: [{ fromLocationId: warehouseId }, { toLocationId: warehouseId }], // [cite: 153, 155]
        movementDate: { gte: startDate, lte: endDate }, // [cite: 161]
      },
      include: {
        variant: { include: { product: true } }, // [cite: 151]
        fromLocation: true, // [cite: 154]
        toLocation: true, // [cite: 156]
        member: { include: { user: true } }, // [cite: 161]
      },
    });

    const reportData: WarehouseReportData = {
      warehouse_info: warehouseDetails,
      variant_stock_levels: variantStocks,
      stock_batches: stockBatches,
      stock_movements: stockMovements,
    };

    return {
      report_type: 'Warehouse',
      data: reportData,
      generated_at: new Date().toISOString(),
    };
  } catch (e: any) {
    return { error: `Failed to generate warehouse report: ${e.message}` };
  }
}

async function generateMembersReport(
  prisma: any,
  organizationId: string,
  startDate: Date,
  endDate: Date,
  memberIds?: string[]
): Promise<ReportResponse | ReportError> {
  try {
    console.log(
      `Generating Members Report for Organization ID: ${organizationId} from ${startDate.toISOString()} to ${endDate.toISOString()}`
    );
    const memberFilters: any = {
      organizationId: organizationId, // [cite: 9]
      createdAt: { gte: startDate, lte: endDate }, // [cite: 9, 10]
    };
    if (memberIds && memberIds.length > 0) {
      memberFilters.id = { in: memberIds }; // [cite: 9]
    }

    const membersDetails = await prisma.member.findMany({
      where: memberFilters,
      include: {
        user: true, // [cite: 9]
        departmentMemberships: { include: { department: true } }, // [cite: 12]
        sales: {
          // [cite: 10]
          where: { saleDate: { gte: startDate, lte: endDate } },
          take: 10, // Limiting for brevity
        },
        submittedExpenses: {
          // [cite: 12]
          where: { expenseDate: { gte: startDate, lte: endDate } },
          take: 10,
        },
        attendanceLogs: {
          // [cite: 17]
          where: { checkInTime: { gte: startDate, lte: endDate } },
          orderBy: { checkInTime: 'desc' },
          take: 10,
        },
      },
    });

    let reportData: MembersReportData;

    if (!membersDetails || membersDetails.length === 0) {
      reportData = { members: [], message: 'No members found for the given criteria.' };
    } else {
      reportData = { members: membersDetails };
    }

    return {
      report_type: 'Members',
      data: reportData,
      generated_at: new Date().toISOString(),
    };
  } catch (e: any) {
    return { error: `Failed to generate members report: ${e.message}` };
  }
}

async function generateOrganizationReport(
  prisma: any,
  organizationId: string,
  startDate: Date,
  endDate: Date
): Promise<ReportResponse | ReportError> {
  try {
    console.log(
      `Generating Organization Report for ID: ${organizationId} from ${startDate.toISOString()} to ${endDate.toISOString()}`
    );

    const orgDetails = await prisma.organization.findUnique({
      where: { id: organizationId },
      include: {
        settings: true, // [cite: 22, 23]
        // defaultLocation and defaultWarehouse are direct string IDs in the schema [cite: 19, 20]
        // To fetch their details, you'd do separate queries if needed or adjust the include if Prisma supports it like:
        // defaultLocationDetails: { select: { name: true, id: true } }, // If Organization model had relation for these
      },
    });

    if (!orgDetails) {
      return { error: `Organization with ID ${organizationId} not found.` };
    }

    // Fetch default location and warehouse details if their IDs exist
    if (orgDetails.defaultLocationId) {
      // [cite: 19]
      orgDetails.defaultLocationDetails = await prisma.inventoryLocation.findUnique({
        where: { id: orgDetails.defaultLocationId },
      });
    }
    if (orgDetails.defaultWarehouseId) {
      // [cite: 20]
      orgDetails.defaultWarehouseDetails = await prisma.inventoryLocation.findUnique({
        where: { id: orgDetails.defaultWarehouseId },
      });
    }

    const memberCount = await prisma.member.count({
      where: { organizationId: organizationId, createdAt: { lte: endDate } },
    }); // [cite: 6]
    const customerCount = await prisma.customer.count({
      where: { organizationId: organizationId, createdAt: { lte: endDate } },
    }); // [cite: 18]
    const productCount = await prisma.product.count({
      where: { organizationId: organizationId, createdAt: { lte: endDate } },
    }); // [cite: 20]

    const salesReport = await generateSalesReport(prisma, organizationId, startDate, endDate);
    const expensesReport = await generateExpensesReport(prisma, organizationId, startDate, endDate);

    const salesSummary = (salesReport as ReportResponse)?.data || (salesReport as ReportError);
    const expensesSummary = (expensesReport as ReportResponse)?.data || (expensesReport as ReportError);

    const newCustomersInPeriod = await prisma.customer.count({
      // [cite: 18]
      where: {
        organizationId: organizationId,
        createdAt: { gte: startDate, lte: endDate }, // [cite: 62]
      },
    });

    const reportData: OrganizationReportData = {
      organization_info: orgDetails,
      member_count: memberCount,
      customer_count: customerCount,
      product_count: productCount,
      sales_summary: (salesSummary as SalesReportData)?.summary || salesSummary,
      expenses_summary: (expensesSummary as ExpensesReportData)?.summary || expensesSummary,
      kpis: {
        total_revenue: (salesSummary as SalesReportData)?.summary?.total_sales_value,
        total_expenses: (expensesSummary as ExpensesReportData)?.summary?.total_expenses_value,
        new_customers_in_period: newCustomersInPeriod,
      },
    };

    return {
      report_type: 'Organization',
      data: reportData,
      generated_at: new Date().toISOString(),
    };
  } catch (e: any) {
    return { error: `Failed to generate organization report: ${e.message}` };
  }
}

// --- Main Function to Aggregate and Send Data ---

interface ReportRequest {
  type: 'department' | 'sales' | 'expenses' | 'warehouse' | 'members' | 'organization';
  id?: string; // For department, warehouse, organization
  org_id?: string; // For sales, expenses, members
  member_id?: string; // Optional for sales, expenses
  location_id?: string; // Optional for sales
  category_id?: string; // Optional for expenses
  member_ids?: string[]; // Optional for members
}

async function processAndSendReportsToGemini(
  prisma: any, // Pass your Prisma client instance
  reportRequests: ReportRequest[],
  startDateStr: string,
  endDateStr: string
): Promise<{ status: string; data_for_gemini: (ReportResponse | ReportError)[] } | ReportError> {
  let startDate: Date, endDate: Date;
  try {
    startDate = new Date(startDateStr);
    endDate = new Date(endDateStr);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      throw new Error('Invalid date string provided.');
    }
  } catch (e: any) {
    return { error: `Invalid date format. Please use a valid ISO date string (e.g., YYYY-MM-DD): ${e.message}` };
  }

  const allReportsData: (ReportResponse | ReportError)[] = [];

  for (const request of reportRequests) {
    let generatedReport: ReportResponse | ReportError | null = null;
    try {
      switch (request.type) {
        case 'department':
          if (!request.id) {
            generatedReport = { error: 'Department ID is required.' };
            break;
          }
          generatedReport = await generateDepartmentReport(prisma, request.id, startDate, endDate);
          break;
        case 'sales':
          if (!request.org_id) {
            generatedReport = { error: 'Organization ID is required for sales report.' };
            break;
          }
          generatedReport = await generateSalesReport(
            prisma,
            request.org_id,
            startDate,
            endDate,
            request.member_id,
            request.location_id
          );
          break;
        case 'expenses':
          if (!request.org_id) {
            generatedReport = { error: 'Organization ID is required for expenses report.' };
            break;
          }
          generatedReport = await generateExpensesReport(
            prisma,
            request.org_id,
            startDate,
            endDate,
            request.member_id,
            request.category_id
          );
          break;
        case 'warehouse':
          if (!request.id) {
            generatedReport = { error: 'Warehouse ID is required.' };
            break;
          }
          generatedReport = await generateWarehouseReport(prisma, request.id, startDate, endDate);
          break;
        case 'members':
          if (!request.org_id) {
            generatedReport = { error: 'Organization ID is required for members report.' };
            break;
          }
          generatedReport = await generateMembersReport(prisma, request.org_id, startDate, endDate, request.member_ids);
          break;
        case 'organization':
          if (!request.id) {
            generatedReport = { error: 'Organization ID is required.' };
            break;
          }
          generatedReport = await generateOrganizationReport(prisma, request.id, startDate, endDate);
          break;
        default:
          generatedReport = { error: `Unknown report type: ${(request as any).type}` };
      }
      if (generatedReport) {
        allReportsData.push(generatedReport);
      }
    } catch (e: any) {
      allReportsData.push({
        error: `An unexpected error occurred while processing ${request.type} report for ID ${request.id || request.org_id}: ${e.message}`,
      });
    }
  }

  // Conceptual: Send data to Gemini API
  // const geminiApiResponse = await sendToGeminiApi(allReportsData);
  // console.log("Data sent to Gemini API. Response:", geminiApiResponse);

  console.log('\n--- All Generated Report Data (Conceptual Gemini API Input) ---');
  allReportsData.forEach(reportOutput => console.log(JSON.stringify(reportOutput, null, 2)));
  console.log('--- End of Report Data ---');

  return { status: 'Reports processed', data_for_gemini: allReportsData };
}

async function sendToGeminiApi(dataPayload: any): Promise<any> {
  console.log('\n[GEMINI API SIM TypeScript] Sending the following payload to Gemini API:');
  // In a real scenario, you would use an HTTP client (like fetch or axios)
  // to POST this data to the Gemini API endpoint and handle the response.
  // console.log(JSON.stringify(dataPayload, null, 2));

  // Simulate an API call with a delay
  await new Promise(resolve => setTimeout(resolve, 500));

  return { status: 'success', message: 'Data received by Gemini API (TypeScript)', echo: dataPayload };
}

// --- Example Usage (Illustrative) ---
async function mainExample() {
  // This is an illustrative example.
  // You'll need to instantiate PrismaClient and pass it.
  // const prisma = new PrismaClient(); // Your actual Prisma client

  const mockPrisma = {
    // Mock Prisma client for example execution without a DB
    department: {
      findUnique: async (args: any) => {
        console.log('Mock prisma.department.findUnique', args);
        if (args.where.id === 'dept_123')
          return { id: 'dept_123', name: 'TypeScript Sales Dept', budgets: [], departmentMembers: [] };
        return null;
      },
    },
    expense: {
      findMany: async (args: any) => {
        console.log('Mock prisma.expense.findMany', args);
        return [];
      },
    },
    sale: {
      findMany: async (args: any) => {
        console.log('Mock prisma.sale.findMany', args);
        return [{ id: 's1', finalAmount: new (require('decimal.js'))(100) }];
      },
    }, // Prisma Decimal fields need new Decimal()
    inventoryLocation: {
      findFirst: async (args: any) => {
        console.log('Mock prisma.inventoryLocation.findFirst', args);
        return null;
      },
      findUnique: async (args: any) => null,
    },
    productVariantStock: {
      findMany: async (args: any) => {
        console.log('Mock prisma.productVariantStock.findMany', args);
        return [];
      },
    },
    stockBatch: {
      findMany: async (args: any) => {
        console.log('Mock prisma.stockBatch.findMany', args);
        return [];
      },
    },
    stockMovement: {
      findMany: async (args: any) => {
        console.log('Mock prisma.stockMovement.findMany', args);
        return [];
      },
    },
    member: {
      findMany: async (args: any) => {
        console.log('Mock prisma.member.findMany', args);
        return [];
      },
      count: async (args: any) => 5,
    },
    organization: {
      findUnique: async (args: any) => {
        console.log('Mock prisma.organization.findUnique', args);
        if (args.where.id === 'org_abc') return { id: 'org_abc', name: 'TS Company' };
        return null;
      },
    },
    customer: { count: async (args: any) => 3 },
    product: { count: async (args: any) => 50 },
  };

  const reportRequestsPayload: ReportRequest[] = [
    { type: 'department', id: 'dept_123' },
    { type: 'sales', org_id: 'org_abc' },
    { type: 'organization', id: 'org_abc' },
  ];

  const start = '2024-01-01';
  const end = '2024-03-31';

  const finalOutput = await processAndSendReportsToGemini(mockPrisma as any, reportRequestsPayload, start, end);

  // console.log("\n--- Final Processed Output (TypeScript) ---");
  // console.log(JSON.stringify((finalOutput as any).data_for_gemini, null, 2));

  // await prisma.$disconnect(); // Disconnect Prisma client when done
}

// To run the example:
// mainExample().catch(e => console.error(e));
